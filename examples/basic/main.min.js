var sim2dTest = (function (exports) {
  'use strict';

  function initTileCoords( params ) {

    // Initialize position and zoom of the map. All are integers
    var zoom = Math.floor( Math.log2( Math.max(params.nx, params.ny) ) );
    var xTile0 = 0;
    var yTile0 = 0;

    // Transform parameters
    var nTiles = 2 ** zoom;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    function updateTransform() {
      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / params.nx; // Problematic if < 1 ?
      scale[1] = nTiles / params.ny;
    }
    // Initialize transform
    updateTransform();

    return {
      // Info about current map state
      getScale: function(i) { return scale[i]; },
      getZXY,

      // Methods to compute positions within current map
      toLocal,
      xyToMapPixels,
      tileDistance,

      // Methods to update map state
      fitBoundingBox,
      move,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
      return;
    }

    function xyToMapPixels(local, global) {
      toLocal(local, global);
      local[0] *= params.nx * params.tileSize;
      local[1] *= params.ny * params.tileSize;
      return;
    }

    function tileDistance(z, x, y) {
      // Given input tile indices, return a distance metric
      // indicating how far the input tile is from the current map

      // Find edges of tile and map, in units of tiles at current map zoom
      var zoomFac = 2 ** (zoom - z);
      var tile = {
        x1: x * zoomFac,
        x2: (x + 1) * zoomFac,
        y1: y * zoomFac,
        y2: (y + 1) * zoomFac,
      };
      var map = {
        x1: xTile0,
        x2: xTile0 + params.nx + 1, // Note: may extend across antimeridian!
        y1: yTile0,
        y2: yTile0 + params.ny + 1, // Note: may extend across a pole!
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      //             where a "tile" is measured at map zoom level

      // Note: need to be careful with distances crossing an antimeridian or pole
      var xdist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.x1 - tile.x2, tile.x1 - map.x2),
          // Re-test with tile shifted across antimeridian 
          Math.max(map.x1 - (tile.x2 + nTiles), (tile.x1 + nTiles) - map.x2)
          );
      var ydist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.y1 - tile.y2, tile.y1 - map.y2),
          // Re-test with tile shifted across pole 
          Math.max(map.y1 - (tile.y2 + nTiles), (tile.y1 + nTiles) - map.y2)
          );
      // Use the largest distance
      var hdist = Math.max(xdist, ydist);

      // Adjust for zoom difference
      return hdist - 1.0 + 1.0 / zoomFac;
    }

    function toLocal(local, global) {
      // Input global and output local are pointers to 2-element arrays [X,Y]

      // Translate to local origin. Question: should we just use vec2 routines?
      local[0] = global[0] - origin[0];
      local[1] = global[1] - origin[1];

      // Check for wrapping across antimeridian 
      // NOTE: if point is to left of origin, it will be wrapped to right?
      // We might prefer to put it as close as possible to the center
      local[0] = wrap(local[0], 1.0);

      // Scale to the size of the local map
      local[0] *= scale[0];
      local[1] *= scale[1];

      return;
    }

    function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of X/Y coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)
      // TODO: update comment, verify code for non-Mercator projections

      // Remember old values
      var oldZ = zoom;
      var oldX = xTile0;
      var oldY = yTile0;

      // 1. Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.
      // (allows panning to where p1[0] is near the right edge of a tile.)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (gridSize? - 1) / 2 ** zoom > boxSize in both X and Y.
      // BUT we need the minimum zoom to have at least gridSize, i.e.,
      // min zoom = log2(gridSize).
      var zoomX = Math.log2( Math.max(params.nx, (params.nx - 1) / boxWidth) );
      var zoomY = Math.log2( Math.max(params.ny, (params.ny - 1) / boxHeight) );
      zoom = Math.floor( Math.min(zoomX, zoomY) );
      zoom = Math.min(zoom, params.maxZoom);
      nTiles = 2 ** zoom; // Number of tiles at this zoom level

      // 2. Compute the tile indices of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0) * nTiles;
      if (centerX > nTiles) centerX -= nTiles;
      var centerY = 0.5 * (p1[1] + p2[1]) * nTiles;

      // 3. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      xTile0 = Math.round(centerX - params.nx / 2.0);
      xTile0 = wrap(xTile0, nTiles); // in case we crossed the antimeridian
      yTile0 = Math.round(centerY - params.ny / 2.0);
      // Don't let box cross poles
      yTile0 = Math.min(Math.max(0, yTile0), nTiles - params.ny);

      // Return a flag indicating whether map parameters were updated
      if (zoom !== oldZ || xTile0 !== oldX || yTile0 !== oldY) {
        updateTransform();
        return true;
      }
      return false;
    }

    function move(dz, dx, dy) {
      var dzi = Math.round(dz);
      var dxi = Math.round(dx);
      var dyi = Math.round(dy);

      // Don't zoom beyond the limits of the API
      dzi = Math.min(Math.max(0 - zoom, dzi), params.maxZoom - zoom);

      var changed = (dzi || dxi || dyi);

      // Panning first
      xTile0 = wrap(xTile0 + dxi, nTiles);
      yTile0 = wrap(yTile0 + dyi, nTiles);

      while (dzi > 0) {  // Zoom in
        zoom++;
        xTile0 = Math.floor(2 * xTile0 + params.nx / 2.0);
        yTile0 = Math.floor(2 * yTile0 + params.ny / 2.0);
        dzi--;
      }
      while (dzi < 0) {  // Zoom out
        zoom--;
        xTile0 = wrap( Math.ceil( (xTile0 - params.nx / 2.0) / 2 ), nTiles );
        yTile0 = wrap( Math.ceil( (yTile0 - params.ny / 2.0) / 2 ), nTiles );
        dzi++;
      }

      updateTransform();
      return changed;
    }

  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initTileCache(tileAPI) {
    const size = tileAPI.tileSize;

    // Initialize the tiles object
    const tiles = {};

    // Return methods for accessing and updating the tiles
    return {
      retrieve,
      prune,
    };

    function retrieve(tile, zxy) {
      tile.found = false;
      getTileOrParent(tile, zxy[0], zxy[1], zxy[2], 0, 0, size);
      return tile.found;
    }

    function getTileOrParent(
        tileObj,     // Returned tile object
        z, x, y,     // Coordinates of the requested tile
        sx, sy, sw   // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object
      let id = tileAPI.getID(z, x, y);

      // If the tile exists and is ready, return it with cropping info
      if (tiles[id] && tiles[id].complete && tiles[id].naturalWidth !== 0) {
        tileObj.img = tiles[id];
        tileObj.sx = sx;
        tileObj.sy = sy;
        tileObj.sw = sw;
        tileObj.found = true;
        return;
      }

      // Looks like the tile wasn't ready. Try using the parent tile
      if (z > 0 && sw > 1) { // Don't look too far back
        // Get coordinates and cropping parameters of the parent
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        getTileOrParent(tileObj, pz, px, py, psx, psy, psw); // recursive call!
      }

      if (!tiles[id]) {  // Tile didn't exist. Create it and request image from API
        tiles[id] = new Image();
        tiles[id].zoom = z;
        tiles[id].indx = x;
        tiles[id].indy = y;
        tiles[id].crossOrigin = "anonymous";
        tiles[id].src = tileAPI.getURL(id);
      }

      return;
    }

    function prune(metric, threshold) {
      // Remove tiles far from current view (as measured by metric)

      for ( let id in tiles ) {
        let distance = metric(tiles[id].zoom, tiles[id].indx, tiles[id].indy);
        if (distance >= threshold) {
          tiles[id].src = ""; // Cancel any outstanding request (is it necessary?)
          delete tiles[id];
        }
      }
      return;
    }

  }

  function initMap(params, context, coords, tiles) {
    // Resize canvas to fit the specified number of tiles
    const size = params.tileSize;
    const mapWidth = params.nx * size;
    const mapHeight = params.ny * size;
    context.canvas.width = mapWidth;
    context.canvas.height = mapHeight;

    // Initialize tracking object, to check if map needs to be updated
    const dz = [];
    for (let iy = 0; iy < params.ny; iy++) {
      dz[iy] = [];
    }
    const oneTileComplete = 1. / params.nx / params.ny;
    const mapStatus = {
      complete: 0.0,
      dz,
      reset: function() {
        this.complete = 0.0;
        for (let iy = 0; iy < params.ny; iy++) {
          for (let ix = 0; ix < params.nx; ix++) {
            // dz indicates the difference between the requested zoom level
            // and the zoom level actually written to this tile
            dz[iy][ix] = params.maxZoom;
          }
        }
        return;
      },
    };
    mapStatus.reset(); // Initializes dz

    // Return methods for drawing a 2D map
    return {
      loaded: function() {
        return mapStatus.complete;
      },
      drawTiles,
      reset,
    };

    function drawTiles() {
      // Quick exit if map is already complete.
      if ( mapStatus.complete === 1.0 ) return false; // No change!

      var updated = false;
      const tileObj = {};
      const zxy = [];

      // Loop over tiles in the map
      for (let iy = 0; iy < params.ny; iy++) {
        for (let ix = 0; ix < params.nx; ix++) {
          if (mapStatus.dz[iy][ix] === 0) continue; // This tile already done

          coords.getZXY(zxy, ix, iy);
          var foundTile = tiles.retrieve( tileObj, zxy );
          if (!foundTile) continue; // No image available for this tile
          var dzTmp = zxy[0] - tileObj.img.zoom;
          if (dzTmp == mapStatus.dz[iy][ix]) continue; // Tile already written

          context.drawImage(
              tileObj.img,    // Image to read, and paint to the canvas
              tileObj.sx,     // First x-pixel in tile to read
              tileObj.sy,     // First y-pixel in tile to read
              tileObj.sw,     // Number of pixels to read in x
              tileObj.sw,     // Number of pixels to read in y
              ix * size,      // First x-pixel in canvas to paint
              iy * size,      // First y-pixel in canvas to paint
              size,           // Number of pixels to paint in x
              size            // Number of pixels to paint in y
              );
          updated = true;

          if (dzTmp == 0) mapStatus.complete += oneTileComplete;
          mapStatus.dz[iy][ix] = dzTmp;
        }
      }
      return updated;
    }

    function reset() {
      mapStatus.reset();
      context.clearRect(0, 0, mapWidth, mapHeight);
      return;
    }
  }

  function initBoxQC(overlay, coords, width, height) {

    // Resize canvases to fit the specified number of tiles
    overlay.canvas.width = width;
    overlay.canvas.height = height;

    // Track status of bounding box for QC
    const boxQC = [ [0,0], [0,0] ];
    const pixQC = [ [0,0], [0,0] ];

    // Return methods for drawing the QC
    return {
      draw,
      reset,
    };

    function draw(p1, p2, mapChanged) {
      // Check if bounding box changed since last call
      var boxChanged = updateBox(boxQC, [p1, p2]);
      if (!boxChanged && !mapChanged) return;

      // Special case: box moved but map didn't
      if (!mapChanged) overlay.clearRect(0, 0, width, height);

      // Convert box to map pixels
      coords.xyToMapPixels( pixQC[0], boxQC[0] );
      coords.xyToMapPixels( pixQC[1], boxQC[1] );

      // Draw bounding box on overlay
      overlay.strokeStyle = "#FF0000";
      overlay.lineWidth = 5;
      overlay.strokeRect(
          pixQC[0][0],
          pixQC[0][1],
          pixQC[1][0] - pixQC[0][0],
          pixQC[1][1] - pixQC[0][1]
          );

      return;
    }

    function updateBox(bOld, bNew) {
      var same = (
          bNew[0][0] === bOld[0][0] &&
          bNew[0][1] === bOld[0][1] &&
          bNew[1][0] === bOld[1][0] &&
          bNew[1][1] === bOld[1][1]
          );
      if (same) return false;

      // Box changed. Do a deep copy
      bOld[0][0] = bNew[0][0];
      bOld[0][1] = bNew[0][1];
      bOld[1][0] = bNew[1][0];
      bOld[1][1] = bNew[1][1];
      return true;
    }

    function reset() {
      overlay.clearRect(0, 0, width, height);
      boxQC[0][0] = 0;
      boxQC[0][1] = 0;
      boxQC[1][0] = 0;
      boxQC[1][1] = 0;
      return;
    }
  }

  function init(params, context, overlay) {
    // Check if we have a valid canvas rendering context
    var haveRaster = context instanceof CanvasRenderingContext2D;
    if (!haveRaster) {
      console.log("WARNING in rastermap.init: not a 2D rendering context!");
      //return false;
    }

    // Compute pixel size of map
    const mapWidth = params.nx * params.tileSize;
    const mapHeight = params.ny * params.tileSize;
    console.log("map size: " + mapWidth + "x" + mapHeight);

    // Setup tile coordinates and tile cache
    const coords = initTileCoords( params );
    const tiles = initTileCache( params );

    // Initialize grid of rendered tiles
    const map = initMap(params, context, coords, tiles);

    // Initialize bounding box QC overlay
    var boxQC;
    var haveVector = overlay instanceof CanvasRenderingContext2D;
    if (haveVector) {
      boxQC = initBoxQC(overlay, coords, mapWidth, mapHeight);
    }

    // Return methods for drawing a 2D map
    return {
      drawTiles,
      loaded: map.loaded,
      move: function(dz, dx, dy) {
        var changed = coords.move(dz, dx, dy);
        if (changed) reset();
      },
      fitBoundingBox,
      toLocal: coords.toLocal,
      getScale: coords.getScale,
      xyToMapPixels: coords.xyToMapPixels,
    };

    function fitBoundingBox(p1, p2) {
      var mapChanged = coords.fitBoundingBox(p1, p2);
      if (mapChanged) reset();
      if (haveVector) boxQC.draw(p1, p2, mapChanged);
      return;
    }

    function drawTiles() {
      var updated = map.drawTiles();
      // Clean up -- don't let images object get too big
      tiles.prune(coords.tileDistance, 3.5);
      return updated;
    }

    function reset() {
      map.reset();
      if (haveVector) boxQC.reset();
      return;
    }
  }

  const params = Object.freeze({
    // Root URL and token for accessing the REST API
    baseURL: "https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/",
    token: "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA",
    
    // Number of zoom levels
    maxZoom: 20,
    
    // Width of a tile in pixels (ASSUMES square tiles)
    tileSize: 256,
    
    // Specify number of tiles in the map, in each direction
    nx: 4,
    ny: 3,
    
    // Specify how to get the unique ID of a tile, given its zoom and x/y indices
    getID: function(zoom, x, y) {
      return "/" + zoom + "/" + x + "/" + y + "/";
    },
    
    // Specify how to construct the URL for a given tile, from its unique ID
    getURL: function(id) {
      return this.baseURL + this.tileSize + id + "?access_token=" + this.token;
    },
  });

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function lonLatToXY(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX( geodetic[0] );
    projected[1] = latToY( geodetic[1] );
    return;
  }

  function lonToX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
    var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);
    var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
    Math.log( Math.tan(Math.PI / 4.0 + clipLat / 2.0) );
    // Clip range to [0,1], since y does not wrap around
    return Math.min(Math.max(0.0, y), 1.0);
  }

  // Very similar to greggman's module:
  // https://github.com/greggman/webgl-fundamentals/blob/master/webgl/resources/webgl-utils.js
  function createAttributeSetters(gl, program) {
    var attribSetters = {};
    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttribs; i++) {
      var attribInfo = gl.getActiveAttrib(program, i);
      if (!attribInfo) break;
      var index = gl.getAttribLocation(program, attribInfo.name);
      attribSetters[attribInfo.name] = createAttribSetter(gl, index);
    }
    return attribSetters;
  }

  function createAttribSetter(gl, index) {
    return function(b) {
      // Enable this attribute (shader attributes are disabled by default)
      gl.enableVertexAttribArray(index);
      // Bind the buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
      // Point the attribute in the program to this buffer,
      // and tell the program the byte layout in the buffer
      gl.vertexAttribPointer(
          index,                      // index of attribute in program
          b.numComponents || b.size,  // Number of elements to read per vertex
          b.type || gl.FLOAT,         // Type of each element
          b.normalize || false,       // Whether to normalize it
          b.stride || 0,              // Byte spacing between vertices
          b.offset || 0               // Byte # to start reading from
          );
    };
  }

  function setBuffersAndAttributes(gl, setters, buffers) {
    setAttributes(setters, buffers.attributes);
    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices.buffer);
    }
  }

  function setAttributes(setters, attribs) {
    Object.keys(attribs).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter( attribs[name] );
    });
  }

  // Very similar to greggman's module:
  // https://github.com/greggman/webgl-fundamentals/blob/master/webgl/resources/webgl-utils.js
  function createUniformSetters(gl, program) {

    var uniformSetters = {};
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    // Track texture bindpoint index in case multiple textures are required
    var textureUnit = 0;

    for (let i = 0; i < numUniforms; i++) {
      var uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) break;

      var name = uniformInfo.name;
      // remove the array suffix added by getActiveUniform
      if (name.substr(-3) === "[0]") {
        name = name.substr(0, name.length - 3);
      }
      var setter = createUniformSetter(program, uniformInfo);
      uniformSetters[name] = setter;
    }
    return uniformSetters;

    // This function must be nested to access the textureUnit index
    function createUniformSetter(program, uniformInfo) {
      var location = gl.getUniformLocation(program, uniformInfo.name);
      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
      var type = uniformInfo.type;
      switch (type) {
        case gl.FLOAT :
          if (isArray) {
            return function(v) { gl.uniform1fv(location, v); };
          } else {
            return function(v) { gl.uniform1f(location, v); };
          }
        case gl.FLOAT_VEC2 :
          return function(v) { gl.uniform2fv(location, v); };
        case gl.FLOAT_VEC3 :
          return function(v) { gl.uniform3fv(location, v); };
        case gl.FLOAT_VEC4 :
          return function(v) { gl.uniform4fv(location, v); };
        case gl.INT :
          if (isArray) {
            return function(v) { gl.uniform1iv(location, v); };
          } else {
            return function(v) { gl.uniform1i(location, v); };
          }
        case gl.INT_VEC2 :
          return function(v) { gl.uniform2iv(location, v); };
        case gl.INT_VEC3 :
          return function(v) { gl.uniform3iv(location, v); };
        case gl.INT_VEC4 :
          return function(v) { gl.uniform4iv(location, v); };
        case gl.BOOL :
          return function(v) { gl.uniform1iv(location, v); };
        case gl.BOOL_VEC2 :
          return function(v) { gl.uniform2iv(location, v); };
        case gl.BOOL_VEC3 :
          return function(v) { gl.uniform3iv(location, v); };
        case gl.BOOL_VEC4 :
          return function(v) { gl.uniform4iv(location, v); };
        case gl.FLOAT_MAT2 :
          return function(v) { gl.uniformMatrix2fv(location, false, v); };
        case gl.FLOAT_MAT3 :
          return function(v) { gl.uniformMatrix3fv(location, false, v); };
        case gl.FLOAT_MAT4 :
          return function(v) { gl.uniformMatrix4fv(location, false, v); };
        case gl.SAMPLER_2D :
        case gl.SAMPLER_CUBE :
          if (isArray) {
            var units = [];
            for (let i = 0; i < uniformInfo.size; i++) { // greggman wrong here!
              units.push(textureUnit++);
            }
            return function(bindPoint, units) {
              return function(textures) {
                gl.uniform1iv(location, units);
                textures.forEach( function(texture, index) {
                  gl.activeTexture(gl.TEXTURE0 + units[index]);
                  gl.bindTexture(bindPoint, texture);
                });
              };
            }(getBindPointForSamplerType(gl, type), units);
          } else {
            return function(bindPoint, unit) {
              return function(texture) {
                //gl.uniform1i(location, units); // Typo? How did it even work?
                gl.uniform1i(location, unit);
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(bindPoint, texture);
              };
            }(getBindPointForSamplerType(gl, type), textureUnit++);
          }
       default:  // we should never get here
          throw("unknown type: 0x" + type.toString(16));
      }
    }
  }

  function getBindPointForSamplerType(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;
    return undefined;
  }

  function setUniforms(setters, values) {
    Object.keys(values).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter(values[name]);
    });
  }

  // Initialize a shader program
  function initShaderProgram(gl, vsSource, fsSource) {
    // NOTE: Load any WebGL extensions before calling this

    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert( 'Unable to initialize the shader program: \n' +
          gl.getProgramInfoLog(shaderProgram) );
      // This is not very good error handling... should be returning the error
      return null;
    }

    return {
      program: shaderProgram,
      attributeSetters: createAttributeSetters(gl, shaderProgram),
      uniformSetters: createUniformSetters(gl,shaderProgram),
    };
  }

  // create shader of a given type, upload source, compile it
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type); // no error handling??

    // Send the source to the shader object
    gl.shaderSource(shader, source);

    // Compile the shader program
    gl.compileShader(shader);

    // Now check for errors
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      // this alert business is sloppy...
      alert( 'An error occurred compiling the shaders: \n' +
          gl.getShaderInfoLog(shader) );
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  function drawOver( gl, programInfo, buffers, uniforms ) {
    // Overwrite whatever is on the canvas, without clearing anything
    // BEWARE: make sure viewport is already set appropriately

    // Set up program, attributes, and uniforms
    gl.useProgram(programInfo.program);
    setBuffersAndAttributes( gl, programInfo.attributeSetters, buffers );
    setUniforms( programInfo.uniformSetters, uniforms );

    // Draw the scene
    gl.drawElements( gl.TRIANGLES, buffers.indices.vertexCount,
        buffers.indices.type, buffers.indices.offset );

    return;
  }

  function clearRect(gl, x, y, width, height) {
    // Set some parameters
    gl.clearColor(0.0, 0.0, 0.0, 0.0); // Clear to transparent black
    gl.clearDepth(1.0);

    // Use scissor to constrain clearing. 
    // See https://stackoverflow.com/a/11545738/10082269
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(x, y, width, height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.disable(gl.SCISSOR_TEST);

    return;
  }

  function initQuadBuffers(gl) {
    // 4 vertices at the corners of the quad
    const vertices = [ -1, -1,  0,    1, -1,  0,    1,  1,  0,   -1,  1,  0 ];
    // Store byte info and load into GPU
    const vertexPositions = {
      buffer: gl.createBuffer(),
      numComponents: 3,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    // Bind to the gl context
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositions.buffer);
    // Pass the array into WebGL
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Texture coordinates assume image has 0,0 at top left
    const texCoordData = [ 0, 1,   1, 1,   1, 0,   0, 0 ];
    const texCoords = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoords.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoordData), gl.STATIC_DRAW);

    // Index into two triangles
    var indices = [ 0,  1,  2,    2,  3,  0 ];
    const vertexIndices = {
      buffer: gl.createBuffer(),
      vertexCount: indices.length,
      type: gl.UNSIGNED_SHORT,
      offset: 0
    };
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndices.buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    return {
      attributes: {
        aVertexPosition: vertexPositions,
        aTexCoord: texCoords,
      },
      indices: vertexIndices,
    };
  }

  function initTexture(gl, width, height) {
    // Initializes a 2D texture object, extending the default gl.createTexture()
    // The GL context and the binding target are implicitly saved in the closure.
    // Returns the sampler (as a property) along with update and replace methods.
    // Input data is an ImageData object

    const target = gl.TEXTURE_2D;
    const texture = gl.createTexture();
    gl.bindTexture(target, texture);

    // Initialize with default parameters
    const level = 0;  // Mipmap level
    const internalFormat = gl.RGBA;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;
    const border = 0;

    gl.texImage2D(target, level, internalFormat, width, height, border,
        srcFormat, srcType, null);

    // Set up mipmapping and anisotropic filtering, if appropriate
    setupMipMaps(gl, target, width, height);
    setTextureAnisotropy(gl, target);

    return {
      sampler: texture,
      replace,
      update,
    }

    function replace( image ) {
      // Replaces the texture with the supplied image data
      // WARNING: will change texture width/height to match the image
      gl.bindTexture(target, texture);
      gl.texImage2D(target, level, internalFormat, srcFormat, srcType, image);

      // Re-do mipmap setup, since width/height may have changed
      setupMipMaps(gl, target, image.width, image.height);
      return;
    }

    function update( image ) {
      // Updates a portion of the texture with the supplied image data.
      gl.bindTexture(target, texture);

      // Image will be written starting from the pixel (xoffset, yoffset).
      // If these values are not set on the input, use (0,0)
      var xoff = image.xoffset || 0;
      var yoff = image.yoffset || 0;
      gl.texSubImage2D(target, level, xoff, yoff, srcFormat, srcType, image);

      setupMipMaps(gl, target, image.width, image.height);
      return;
    }
  }

  function setupMipMaps(gl, target, width, height) {
    // We are using WebGL1 (for compatibility with mobile browsers) which can't
    // handle mipmapping for non-power-of-2 images. Maybe we should provide
    // pre-computed mipmaps? see https://stackoverflow.com/a/21540856/10082269
    if (isPowerOf2(width) && isPowerOf2(height)) {
      gl.generateMipmap(target);
      // Clamp to avoid wrapping around poles
      // TODO: this may not work with circular coordinates?
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    } else { // Turn off mipmapping 
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // Set wrapping to clamp to edge
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    return;
  }

  function setTextureAnisotropy(gl, target) {
    var ext = (
        gl.getExtension('EXT_texture_filter_anisotropic') ||
        gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || 
        gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        );
    if (ext) {
      var maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      // BEWARE: this texParameterf call is slow on Intel integrated graphics.
      // Avoid this entire function if at all possible.
      gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, 
          maxAnisotropy);
    }
    return;
  }

  function isPowerOf2(value) {
    // This trick uses bitwise operators.
    // See https://stackoverflow.com/a/30924333/10082269
    return value && !(value & (value - 1));
    // For a better explanation, with some errors in the solution, see
    // https://stackoverflow.com/a/30924360/10082269
  }

  var vertexSrc = "attribute vec4 aVertexPosition;\nattribute vec2 aTexCoord;\n\nuniform vec2 uSourceOrigin; // sx, sy\nuniform vec2 uSourceScale;  // sWidth, sHeight\nuniform vec2 uDestOrigin;   // dx, dy\nuniform vec2 uDestScale;    // dWidth, dHeight\n\nvarying highp vec2 vTexCoord;\n\nvoid main(void) {\n  vTexCoord = aTexCoord * uSourceScale + uSourceOrigin;\n  gl_Position = vec4(\n      aVertexPosition.x * uDestScale.x + uDestOrigin.x,\n      aVertexPosition.y * uDestScale.y + uDestOrigin.y,\n      aVertexPosition.z,\n      aVertexPosition.w\n      );\n}\n";

  var fragmentSrc = "precision highp float;\nprecision highp sampler2D;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D uTextureSampler;\n\nvoid main(void) {\n  gl_FragColor = texture2D(uTextureSampler, vTexCoord);\n}\n";

  const quadShaders = {
    vert: vertexSrc,
    frag: fragmentSrc,
  };

  function initRenderer(gl, fbSize) {
    // Input gl is a WebGL rendering context
    // Input fbSize is an object with properties width, height

    // Initialize shader program
    const progInfo = initShaderProgram(gl, quadShaders.vert, quadShaders.frag);

    // Load data into GPU for shaders: attribute buffers, indices
    const buffers = initQuadBuffers(gl);
    // Initialize texture for rendering images to framebuffer. Size is arbitrary?
    const texture = initTexture(gl, fbSize.width, fbSize.height);

    // Store links to uniforms
    const uniforms = {
      uSourceOrigin: new Float64Array(2),
      uSourceScale: new Float64Array(2),
      uDestOrigin: new Float64Array(2),
      uDestScale: new Float64Array(2),
      uTextureSampler: texture.sampler,
    };

    return {
      drawImage,
      clearRect: clearRect$1,
    };

    function drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
      // Fill in missing parameters. Possible parameter sets:
      // (image, dx, dy)
      // (image, dx, dy, dWidth, dHeight)
      // (image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
      // The below logic follows
      // https://webglfundamentals.org/webgl/lessons/webgl-2d-drawimage.html
      if (dx === undefined) {
        dx = sx;
        sx = 0;
      }
      if (dy === undefined) {
        dy = sy;
        sy = 0;
      }
      if (sWidth === undefined) {
        sWidth = image.width;
      }
      if (sHeight === undefined) {
        sHeight = image.height;
      }
      if (dWidth === undefined) {
        dWidth = sWidth;
        sWidth = image.width;
      }
      if (dHeight === undefined) {
        dHeight = sHeight;
        sHeight = image.height;
      }

      // Set source origin/scale: which part of the image to read
      // Image coordinates are from 0 to 1, top left to bottom right
      uniforms.uSourceOrigin[0] = sx / image.width;
      uniforms.uSourceOrigin[1] = sy / image.height;
      uniforms.uSourceScale[0] = sWidth / image.width;
      uniforms.uSourceScale[1] = sHeight / image.height;

      // Set destination origin/scale: where on the canvas to write
      // WebGL canvas coordinates are from -1 to +1, bottom left to top right
      // We can think of the "origin" as the shift of the CENTER of the quad
      // relative to the CENTER of the canvas
      var xscale = dWidth / fbSize.width;
      var yscale = dHeight / fbSize.height;
      uniforms.uDestOrigin[0] = -1.0 + 2.0 * dx / fbSize.width + xscale;
      uniforms.uDestOrigin[1] =  1.0 - 2.0 * dy / fbSize.height - yscale;
      uniforms.uDestScale[0] = xscale;
      uniforms.uDestScale[1] = yscale;

      // Clear the area we're about to draw 
      // TODO: Not necessary with no depth test? What about transparency?
      //clearRect(dx, dy, dWidth, dHeight);

      draw(image);
      return;
    }

    function draw(image) {
      // Load image into texture
      texture.replace( image );  // TODO: this uses mipmaps--inefficient?

      // Set viewport. NOTE: no scissor test!
      gl.viewport(0, 0, fbSize.width, fbSize.height);

      drawOver( gl, progInfo, buffers, uniforms );
      return;
    }

    function clearRect$1(x, y, width, height) {
      // Flip the y-axis to be consistent with WebGL coordinates
      var yflip = fbSize.height - y - height;

      clearRect(gl, x, yflip, width, height);
      return;
    }
  }

  function initSim2d(gl, fb, fbWidth, fbHeight) {
    // Store link to the framebuffer
    var haveFB = (fb instanceof WebGLFramebuffer);
    if (!haveFB) console.log("initSim2d WARNING: no framebuffer supplied!");
    const framebuffer = (haveFB)
      ? fb
      : null;  // Default to the canvas framebuffer of the supplied context

    // Store width and height of framebuffer in an updateable canvas property
    var canvas;
    if (!haveFB) {
      // No framebuffer. Use existing context canvas property
      canvas = gl.canvas;
    } else if (fbWidth && fbHeight) {
      // Use supplied values
      canvas = {
        width: fbWidth,
        height: fbHeight,
      };
    } else {
      // Use size of context canvas for now
      canvas = {
        width: gl.canvas.width,
        height: gl.canvas.height,
      };
    }

    // Initialize renderer (returns methods drawImage, clearRect)
    const render = initRenderer(gl, canvas);

    return {
      canvas,
      drawImage,
      clearRect,
    };

    function drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
      // If we are rendering to a framebuffer, bind it first
      if (haveFB) gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

      // Pass on the call.  TODO: this is messy
      render.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);

      // Rebind the default canvas buffer
      if (haveFB) gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      return;
    }

    function clearRect(x, y, width, height) {
      // If we are rendering to a framebuffer, bind it first
      if (haveFB) gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

      // Pass on the call to the renderer. TODO: this is messy
      render.clearRect(x, y, width, height);

      // Rebind the default canvas buffer
      if (haveFB) gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      return;
    }
  }

  function main() {
    // Setup 2D map: Get canvas for WebGL
    const canvas = document.getElementById("rasterCanvas");
    // Force to preserve drawingbuffer, to avoid clearing during compositing.
    // See https://stackoverflow.com/a/27814683/10082269
    const display = canvas.getContext("webgl", { preserveDrawingBuffer: true });
    // Set drawingbuffer for sim2d -- will be set again in rasterMap.init()
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    // Create simulated 2d canvas as wrapper on WebGL context
    const ctx2d = initSim2d(display);
    // Get overlay canvas for drawing bounding boxes
    const overlay = document.getElementById("vectorCanvas").getContext("2d");

    // Now initialize the map
    const map = init(params, ctx2d, overlay);

    // Handle a supplied bounding box
    var westDeg = document.getElementById("west");
    var eastDeg = document.getElementById("east");
    var northDeg = document.getElementById("north");
    var southDeg = document.getElementById("south");
    var bboxSet = document.getElementById("bboxSet");
    bboxSet.addEventListener("click", function(click) {
      var p1 = [];
      lonLatToXY( p1, 
          [toRadians(westDeg.value), toRadians(northDeg.value)] );
      var p2 = [];
      lonLatToXY( p2,
          [toRadians(eastDeg.value), toRadians(southDeg.value)] );
      map.fitBoundingBox(p1, p2);
    }, false);

    function toRadians(degrees) {
      return degrees * Math.PI / 180.0;
    }
    // Setup panning controls
    var up = document.getElementById("up");
    up.addEventListener("click", function(click) { map.move(0, 0, -1); }, false);
    var down = document.getElementById("down");
    down.addEventListener("click", function(click) { map.move(0, 0, 1); }, false);
    var left = document.getElementById("left");
    left.addEventListener("click", function(click) { map.move(0, -1, 0); }, false);
    var right = document.getElementById("right");
    right.addEventListener("click", function(click) { map.move(0, 1, 0); }, false);

    // Setup zoom controls
    var zoomIn = document.getElementById("zoomIn");
    zoomIn.addEventListener("click", function(click) { map.move(1, 0, 0); }, false);
    var zoomOut = document.getElementById("zoomOut");
    zoomOut.addEventListener("click", function(click) { map.move(-1, 0, 0); }, false);

    // Track loading status
    var loaded = document.getElementById("completion");
    // Start animation loop
    requestAnimationFrame(checkRender);
    function checkRender(time) {
      var mapChanged = map.drawTiles();
      var percent = map.loaded() * 100;
      if (percent < 100) {
        loaded.innerHTML = "Loading: " + percent.toFixed(0) + "%";
      } else {
        loaded.innerHTML = "Complete! " + percent.toFixed(0) + "%";
      }
      requestAnimationFrame(checkRender);
    }
  }

  exports.main = main;

  return exports;

}({}));
